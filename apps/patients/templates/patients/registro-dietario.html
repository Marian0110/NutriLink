<!-- ... (El HTML de la plantilla permanece igual que en tu última versión) ... -->
{% extends 'basePerfil.html' %}
{% load static %}
{% block title %}Registro Dietario 24 Horas{% endblock %}

{% block perfilcontent %}
<div class="registro-dietario-content patient-content">
  <h2>Registro de 24 horas</h2>

  <input type="hidden" id="paciente-id" value="{{ paciente.id_paciente }}">
  {% csrf_token %}

  <div id="adecuacion-registro-section" style="margin-bottom: 25px;">
    <h3>Resumen Nutricional y Adecuación</h3>
    <table id="tabla-adecuacion-registro" class="adecuacion-table">
        <thead>
            <tr>
                <th>Nutriente</th>
                <th>Total Consumido</th>
                <th>% Adecuación (vs Req.)</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>Energía (Kcal)</td><td data-consumido="dieta_calorias">-</td><td data-adecuacion="porc_adecuacion_calorico">- %</td></tr>
            <tr><td>Proteínas (g)</td><td data-consumido="dieta_proteinas">-</td><td data-adecuacion="porc_adec_proteinas">- %</td></tr>
            <tr><td>Carbohidratos (g)</td><td data-consumido="dieta_carbohidratos">-</td><td data-adecuacion="porc_adec_carbohidratos">- %</td></tr>
            <tr><td>Lípidos (g)</td><td data-consumido="dieta_lipidos">-</td><td data-adecuacion="porc_adec_lipidos">- %</td></tr>
            <tr><td>Omega 3 (g)</td><td data-consumido="dieta_n3">-</td><td data-adecuacion="porc_adec_n3">- %</td></tr>
            <tr><td>Vitamina A (µg RE)</td><td data-consumido="dieta_vita">-</td><td data-adecuacion="porc_adec_vita">- %</td></tr>
            <tr><td>Vitamina B12 (µg)</td><td data-consumido="dieta_b12">-</td><td data-adecuacion="porc_adec_b12">- %</td></tr>
            <tr><td>Calcio (mg)</td><td data-consumido="dieta_calcio">-</td><td data-adecuacion="porc_adec_calcio">- %</td></tr>
            <tr><td>Hierro (mg)</td><td data-consumido="dieta_hierro">-</td><td data-adecuacion="porc_adec_hierro">- %</td></tr>
            <tr><td>Selenio (µg)</td><td data-consumido="dieta_selenio">-</td><td data-adecuacion="porc_adec_selenio">- %</td></tr>
            <tr><td>Zinc (mg)</td><td data-consumido="dieta_zinc">-</td><td data-adecuacion="porc_adec_zinc">- %</td></tr>
            <tr><td>Potasio (mg)</td><td data-consumido="dieta_potasio">-</td><td data-adecuacion="porc_adec_potasio">- %</td></tr>
            <tr><td>Sodio (mg)</td><td data-consumido="dieta_sodio">-</td><td data-adecuacion="porc_adec_sodio">- %</td></tr>
        </tbody>
    </table>
    <div id="adecuacion-status">Los cálculos de adecuación aparecerán aquí una vez guardado el registro.</div>
  </div>

  <div id="tiempos-comida-container">
    <!-- Los bloques de tiempo de comida se añadirán aquí dinámicamente -->
  </div>

  <div class="acciones-pagina" style="margin-top: 20px; margin-bottom: 25px; display: flex; gap: 10px;">
    <button type="button" id="btn-anadir-tiempo-comida" class="button-secondary">Añadir Tiempo de Comida</button>
    <button type="button" id="btn-guardar-registro-completo" class="button-primary">Guardar y Calcular Adecuación</button>
  </div>

  <div class="notas-registro-container">
    <h3>Notas</h3>
    <textarea id="notas-generales-registro" name="notas_generales_registro" class="textarea-notas" rows="4" placeholder="Suplementos / agua consumida / etc."></textarea>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script>
document.addEventListener('DOMContentLoaded', async () => {
    const pacienteId = document.getElementById('paciente-id').value;
    const csrfToken = document.querySelector('input[name="csrfmiddlewaretoken"]').value;

    const tiemposComidaContainer = document.getElementById('tiempos-comida-container');
    const btnAnadirTiempoComida = document.getElementById('btn-anadir-tiempo-comida');
    const btnGuardarRegistroCompleto = document.getElementById('btn-guardar-registro-completo');
    const notasGeneralesTextarea = document.getElementById('notas-generales-registro');
    const adecuacionStatusDiv = document.getElementById('adecuacion-status');
    const tablaAdecuacionCuerpo = document.getElementById('tabla-adecuacion-registro').querySelector('tbody');

    let ALL_TIEMPOS_COMIDA_DATA = [];
    let ALL_ALIMENTOS_DATA = [];
    const datosAlimentoPorFilaDOM = new Map();
    let mealTimeBlockCounter = 0;

    async function fetchAPI(url, entityName, options = {}) {
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                let errorDetail = `Error HTTP ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorDetail = errorData.mensaje || errorData.detail || JSON.stringify(errorData);
                } catch (e) { /* No es JSON, usar el status text o el errorDetail original */ 
                    errorDetail = response.statusText || errorDetail;
                }
                throw new Error(errorDetail);
            }
            if (response.status === 204) return null; 
            return await response.json();
        } catch (error) {
            console.error(`Excepción en fetchAPI para ${entityName} (${url}):`, error);
            Swal.fire('Error de Carga', `No se pudieron cargar ${entityName}: ${error.message}`, 'error');
            throw error;
        }
    }

    function populateSelect(selectElement, opciones, valorKey, textoKey, placeholderTexto = "Seleccionar...", currentValue = null, disabled = false) {
        selectElement.innerHTML = `<option value="" ${!currentValue ? 'selected' : ''} disabled>${placeholderTexto}</option>`;
        if (!opciones || opciones.length === 0) {
             selectElement.innerHTML += `<option value="" disabled>No hay opciones disponibles</option>`;
             selectElement.disabled = true;
             return;
        }
        opciones.forEach(opcion => {
            const optionEl = document.createElement('option');
            optionEl.value = opcion[valorKey];
            optionEl.textContent = opcion[textoKey];
            if (currentValue && opcion[valorKey].toString() === currentValue.toString()) {
                optionEl.selected = true;
            }
            selectElement.appendChild(optionEl);
        });
        selectElement.disabled = disabled;
    }

    async function cargarDatosBase() {
        try {
            [ALL_TIEMPOS_COMIDA_DATA, ALL_ALIMENTOS_DATA] = await Promise.all([
                fetchAPI('https://nutrilinkapi-production.up.railway.app/api_nutrilink/minuta/obtener_tiempos_comida_con_id', 'tiempos de comida'),
                fetchAPI('https://nutrilinkapi-production.up.railway.app/api_nutrilink/alimento/alimentos', 'alimentos')
            ]);
        } catch (error) {
            if (btnAnadirTiempoComida) btnAnadirTiempoComida.disabled = true;
            if (btnGuardarRegistroCompleto) btnGuardarRegistroCompleto.disabled = true;
            throw error;
        }
    }
    
    function actualizarValoresNutricionalesFilaAlimento(filaAlimento, alimentoData, porciones) {
        const numPorciones = parseFloat(porciones) || 0;
        const inputs = {
            medidaEquiv: filaAlimento.querySelector('.input-medida-equiv'),
            gramos: filaAlimento.querySelector('.input-gramos'),
            kcal: filaAlimento.querySelector('.input-kcal'),
            proteinas: filaAlimento.querySelector('.input-proteinas'),
            carbohidratos: filaAlimento.querySelector('.input-carbohidratos'),
            lipidos: filaAlimento.querySelector('.input-lipidos'),
            n3: filaAlimento.querySelector('.input-n3'),
            vitA: filaAlimento.querySelector('.input-vit_a'),
            vitB12: filaAlimento.querySelector('.input-vit_b12'),
            calcio: filaAlimento.querySelector('.input-calcio'),
            hierro: filaAlimento.querySelector('.input-hierro'),
            selenio: filaAlimento.querySelector('.input-selenio'),
            zinc: filaAlimento.querySelector('.input-zinc'),
            potasio: filaAlimento.querySelector('.input-potasio'),
            sodio: filaAlimento.querySelector('.input-sodio'),
        };

        if (alimentoData && inputs.medidaEquiv) { // Asegurarse que los inputs existen
            inputs.medidaEquiv.value = `${parseFloat(alimentoData.numero_medida).toFixed(2)} ${alimentoData.medida}`;
            const camposBase = {
                gramos: alimentoData.masa, kcal: alimentoData.kcal, proteinas: alimentoData.proteinas_gr,
                carbohidratos: alimentoData.carbohidratos_gr, lipidos: alimentoData.lipidos_gr, n3: alimentoData.n3_gr,
                vitA: alimentoData.vit_a_mcg, vitB12: alimentoData.vit_b12_mcg, calcio: alimentoData.calcio_mg,
                hierro: alimentoData.hierro_mg, selenio: alimentoData.selenio_mcg, zinc: alimentoData.zinc_mg,
                potasio: alimentoData.potasio_mg, sodio: alimentoData.sodio_mg,
            };
            for (const key in camposBase) {
                if (inputs[key]) {
                    const valorBase = parseFloat(camposBase[key]) || 0;
                    inputs[key].value = (valorBase * numPorciones).toFixed(2);
                    inputs[key].readOnly = true;
                }
            }
            if(inputs.gramos) inputs.gramos.readOnly = true;
            if(inputs.kcal) inputs.kcal.readOnly = true;

        } else {
            if(inputs.medidaEquiv) inputs.medidaEquiv.value = '';
            Object.values(inputs).forEach(input => {
                if (input && input !== inputs.medidaEquiv) input.value = '';
            });
            if(inputs.gramos) inputs.gramos.readOnly = false;
            if(inputs.kcal) inputs.kcal.readOnly = false;
            Object.entries(inputs).forEach(([key, input]) => {
                if (input && key !== 'medidaEquiv' && key !== 'gramos' && key !== 'kcal') {
                    input.readOnly = true;
                }
            });
        }
    }
    
    function createMealTimeBlock(tiempoComidaIdPreselect = null, horaPreselect = "", alimentosPreselect = []) {
        const blockId = `mtb-${mealTimeBlockCounter++}`;
        const blockDiv = document.createElement('div');
        blockDiv.classList.add('tiempo-comida-block');
        blockDiv.dataset.blockId = blockId;
        blockDiv.dataset.tiempoId = tiempoComidaIdPreselect || ''; 
        blockDiv.dataset.hora = horaPreselect || ''; 

        const headerDiv = document.createElement('div');
        headerDiv.classList.add('tiempo-comida-header');

        const selectTiempoComida = document.createElement('select');
        selectTiempoComida.classList.add('select-tabla', 'select-tiempo-comida-block');
        selectTiempoComida.name = `tiempo_comida_block_${blockId}`;
        
        const inputHora = document.createElement('input');
        inputHora.type = 'time';
        inputHora.classList.add('input-tabla', 'input-hora-block');
        inputHora.name = `hora_block_${blockId}`;
        inputHora.value = horaPreselect;

        inputHora.addEventListener('change', () => {
            blockDiv.dataset.hora = inputHora.value; 
            reorderMealTimeBlocksByTime();
        });
        
        selectTiempoComida.addEventListener('change', () => {
            blockDiv.dataset.tiempoId = selectTiempoComida.value; 
            updateAllMealTimeSelects();
        });

        const btnEliminarBloque = document.createElement('button');
        btnEliminarBloque.type = 'button';
        btnEliminarBloque.classList.add('button-eliminar-fila');
        btnEliminarBloque.textContent = 'Eliminar Tiempo';
        btnEliminarBloque.style.marginLeft = 'auto';
        btnEliminarBloque.addEventListener('click', () => handleDeleteMealTimeBlock(blockDiv));

        headerDiv.appendChild(document.createTextNode('Tiempo: '));
        headerDiv.appendChild(selectTiempoComida);
        headerDiv.appendChild(document.createTextNode(' Hora: '));
        headerDiv.appendChild(inputHora);
        headerDiv.appendChild(btnEliminarBloque);
        blockDiv.appendChild(headerDiv);

        const tablaAlimentos = document.createElement('table');
        tablaAlimentos.classList.add('alimentos-tabla-block', 'registro-tabla');
        tablaAlimentos.innerHTML = `
            <thead>
                <tr>
                    <th>Alimento</th><th>Medida Equiv.</th><th>Porciones</th><th>Gr</th><th>Kcal</th>
                    <th>Prot.</th><th>Carbs</th><th>Lip.</th><th>N-3</th><th>Vit.A</th><th>Vit.B12</th>
                    <th>Ca</th><th>Fe</th><th>Se</th><th>Zn</th><th>K</th><th>Na</th><th>Acciones</th>
                </tr>
            </thead>
            <tbody></tbody>
        `;
        blockDiv.appendChild(tablaAlimentos);
        const tbodyAlimentos = tablaAlimentos.querySelector('tbody');

        if (alimentosPreselect && alimentosPreselect.length > 0) {
            alimentosPreselect.forEach(alimento => {
                addFoodRowToMealTimeBlock(tbodyAlimentos, blockId, alimento.alimento_id_alimento, parseFloat(alimento.numero_porciones_dieta));
            });
        } else {
            addFoodRowToMealTimeBlock(tbodyAlimentos, blockId); 
        }

        const accionesBloqueDiv = document.createElement('div');
        accionesBloqueDiv.classList.add('acciones-bloque');
        const btnAnadirAlimento = document.createElement('button');
        btnAnadirAlimento.type = 'button';
        btnAnadirAlimento.classList.add('button-secondary');
        btnAnadirAlimento.textContent = 'Añadir Alimento a este Tiempo';
        btnAnadirAlimento.addEventListener('click', () => addFoodRowToMealTimeBlock(tbodyAlimentos, blockId));
        accionesBloqueDiv.appendChild(btnAnadirAlimento);
        blockDiv.appendChild(accionesBloqueDiv);
        
        tiemposComidaContainer.appendChild(blockDiv);
        populateSelect(selectTiempoComida, ALL_TIEMPOS_COMIDA_DATA, 'id_tiempo_comida', 'descripcion', 'Seleccionar Tiempo...', tiempoComidaIdPreselect);

        return blockDiv;
    }

    function addFoodRowToMealTimeBlock(tbodyAlimentos, blockId, alimentoIdPreselect = null, porcionesPreselect = 1) {
        const foodRowId = `food-${blockId}-${tbodyAlimentos.rows.length}`;
        const nuevaFilaAlimento = tbodyAlimentos.insertRow();
        nuevaFilaAlimento.dataset.foodRowId = foodRowId;
        
        nuevaFilaAlimento.innerHTML = `
            <td><select name="alimento_${foodRowId}" class="select-tabla select-alimento"><option value="" selected disabled>Cargando...</option></select></td>
            <td><input type="text" class="input-tabla input-medida-equiv" name="medida_equiv_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-porciones" name="porciones_${foodRowId}" min="0" step="0.1" value="${porcionesPreselect}"></td>
            <td><input type="number" class="input-tabla input-numero input-gramos" name="gramos_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-kcal" name="kcal_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-proteinas" name="proteinas_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-carbohidratos" name="carbohidratos_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-lipidos" name="lipidos_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-n3" name="n3_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-vit_a" name="vit_a_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-vit_b12" name="vit_b12_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-calcio" name="calcio_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-hierro" name="hierro_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-selenio" name="selenio_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-zinc" name="zinc_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-potasio" name="potasio_${foodRowId}" readonly></td>
            <td><input type="number" class="input-tabla input-numero input-sodio" name="sodio_${foodRowId}" readonly></td>
            <td><button type="button" class="button-eliminar-fila button-eliminar-alimento">Eliminar</button></td>
        `;
        const selectAlimento = nuevaFilaAlimento.querySelector('.select-alimento');
        populateSelect(selectAlimento, ALL_ALIMENTOS_DATA, 'id_alimento', 'nombre_alimento', 'Seleccione alimento...', alimentoIdPreselect);

        if (alimentoIdPreselect) {
            const alimentoData = ALL_ALIMENTOS_DATA.find(a => a.id_alimento.toString() === alimentoIdPreselect.toString());
            if (alimentoData) {
                datosAlimentoPorFilaDOM.set(nuevaFilaAlimento, alimentoData);
                actualizarValoresNutricionalesFilaAlimento(nuevaFilaAlimento, alimentoData, porcionesPreselect);
            } else {
                actualizarValoresNutricionalesFilaAlimento(nuevaFilaAlimento, null, porcionesPreselect);
            }
        } else {
            actualizarValoresNutricionalesFilaAlimento(nuevaFilaAlimento, null, porcionesPreselect);
        }
    }

    function getSelectedMealTimeIdsDOM() {
        const selected = [];
        tiemposComidaContainer.querySelectorAll('.select-tiempo-comida-block').forEach(select => {
            if (select.value && select.value !== "") selected.push(parseInt(select.value));
        });
        return selected;
    }

    function updateAllMealTimeSelects() {
        const allBlockSelects = tiemposComidaContainer.querySelectorAll('.select-tiempo-comida-block');
        const overallSelectedIds = getSelectedMealTimeIdsDOM(); 

        allBlockSelects.forEach(currentSelect => {
            const blockDiv = currentSelect.closest('.tiempo-comida-block');
            const currentValueForThisSelect = blockDiv.dataset.tiempoId ? parseInt(blockDiv.dataset.tiempoId) : null;
            
            const availableForThisSelect = ALL_TIEMPOS_COMIDA_DATA.filter(time => {
                return time.id_tiempo_comida === currentValueForThisSelect || 
                       !overallSelectedIds.some(id => id === time.id_tiempo_comida && id !== currentValueForThisSelect);
            });
            
            const currentlySelectedValueInDOM = currentSelect.value; // Guardar el valor actual del DOM
            populateSelect(currentSelect, availableForThisSelect, 'id_tiempo_comida', 'descripcion', 'Seleccionar Tiempo...', currentValueForThisSelect);
            
            // Re-establecer el valor si el dataset.tiempoId no estaba en las opciones disponibles pero sí estaba seleccionado en el DOM
            // Esto es para cuando se carga la página y un tiempo ya estaba seleccionado pero aún no se había filtrado por overallSelectedIds
            if (currentValueForThisSelect && currentSelect.value !== currentValueForThisSelect.toString()) {
                 if (availableForThisSelect.some(opt => opt.id_tiempo_comida === currentValueForThisSelect)) {
                    currentSelect.value = currentValueForThisSelect;
                 } else if (currentlySelectedValueInDOM && availableForThisSelect.some(opt => opt.id_tiempo_comida.toString() === currentlySelectedValueInDOM)) {
                    // Si el dataset.tiempoId ya no es válido (porque otro bloque lo tomó),
                    // pero el valor que *tenía* el select antes de repopular sigue siendo válido, usar ese.
                    currentSelect.value = currentlySelectedValueInDOM;
                    blockDiv.dataset.tiempoId = currentlySelectedValueInDOM; // Actualizar el dataset
                 } else {
                    // Si ni el dataset.tiempoId ni el valor anterior del DOM son válidos,
                    // el select quedará en el placeholder (primera opción disabled).
                    // Y el dataset.tiempoId debería limpiarse o el usuario elegir uno nuevo.
                    blockDiv.dataset.tiempoId = ""; 
                 }
            } else if (!currentValueForThisSelect && currentSelect.value !== "") {
                // Si el dataset no tenía valor pero el select sí, actualizar el dataset.
                blockDiv.dataset.tiempoId = currentSelect.value;
            }

        });
        updateAddMealButtonState();
    }

    function updateAddMealButtonState() {
        if (!btnAnadirTiempoComida || !ALL_TIEMPOS_COMIDA_DATA) return;
        const numBloquesActuales = tiemposComidaContainer.querySelectorAll('.tiempo-comida-block').length;
        const numTotalTiemposComida = ALL_TIEMPOS_COMIDA_DATA.length;
        
        if (ALL_TIEMPOS_COMIDA_DATA.length > 0 && numBloquesActuales < numTotalTiemposComida) {
            btnAnadirTiempoComida.style.display = 'inline-block';
            btnAnadirTiempoComida.disabled = false;
        } else {
            btnAnadirTiempoComida.style.display = 'none';
            btnAnadirTiempoComida.disabled = true;
        }
    }

    async function handleDeleteMealTimeBlock(blockDiv) {
        const result = await Swal.fire({
            title: '¿Eliminar Tiempo de Comida?',
            text: "Esto quitará este tiempo de comida y todos sus alimentos del registro actual. Los cambios se reflejarán al guardar.",
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#d33',
            cancelButtonColor: '#3085d6',
            confirmButtonText: 'Sí, eliminarlo',
            cancelButtonText: 'Cancelar'
        });

        if (result.isConfirmed) {
            blockDiv.querySelectorAll('tr[data-food-row-id]').forEach(foodRow => {
                datosAlimentoPorFilaDOM.delete(foodRow);
            });
            blockDiv.remove();
            updateAllMealTimeSelects(); 
            reorderMealTimeBlocksByTime(); 
        }
    }

    function handleDeleteFoodRow(foodRowElement) {
        const tbody = foodRowElement.closest('tbody');
        if (tbody && tbody.rows.length > 1) {
            datosAlimentoPorFilaDOM.delete(foodRowElement);
            foodRowElement.remove();
        } else { 
            foodRowElement.querySelector('.select-alimento').value = "";
            foodRowElement.querySelector('.input-porciones').value = "1";
            actualizarValoresNutricionalesFilaAlimento(foodRowElement, null, 1);
            datosAlimentoPorFilaDOM.delete(foodRowElement);
        }
    }

    function reorderMealTimeBlocksByTime() {
        const blocks = Array.from(tiemposComidaContainer.querySelectorAll('.tiempo-comida-block'));
        if (blocks.length <= 1) return;

        blocks.sort((a, b) => {
            const timeA = a.dataset.hora; 
            const timeB = b.dataset.hora;
            if (!timeA && !timeB) return 0;
            if (!timeA) return -1; 
            if (!timeB) return 1;  
            return timeA.localeCompare(timeB);
        });

        blocks.forEach(block => tiemposComidaContainer.appendChild(block));
    }

    tiemposComidaContainer.addEventListener('change', (event) => {
        const target = event.target;
        const foodRow = target.closest('tr[data-food-row-id]');
        const blockDiv = target.closest('.tiempo-comida-block');

        if (target.classList.contains('select-tiempo-comida-block') && blockDiv) {
            blockDiv.dataset.tiempoId = target.value; 
            updateAllMealTimeSelects();
        } else if (target.classList.contains('input-hora-block') && blockDiv) {
            blockDiv.dataset.hora = target.value; 
             reorderMealTimeBlocksByTime();
        } else if (target.classList.contains('select-alimento') && foodRow) {
            const alimentoId = target.value;
            const porcionesInput = foodRow.querySelector('.input-porciones');
            
            if (alimentoId && ALL_ALIMENTOS_DATA) { // Asegurar que ALL_ALIMENTOS_DATA esté cargado
                const alimentoSeleccionado = ALL_ALIMENTOS_DATA.find(a => a.id_alimento.toString() === alimentoId);
                datosAlimentoPorFilaDOM.set(foodRow, alimentoSeleccionado);
                if (!porcionesInput.value) porcionesInput.value = "1";
                actualizarValoresNutricionalesFilaAlimento(foodRow, alimentoSeleccionado, porcionesInput.value || "1");
            } else {
                datosAlimentoPorFilaDOM.delete(foodRow);
                actualizarValoresNutricionalesFilaAlimento(foodRow, null, 0);
            }
        }
    });

    tiemposComidaContainer.addEventListener('input', (event) => {
        const target = event.target;
        const foodRow = target.closest('tr[data-food-row-id]');
        if (target.classList.contains('input-porciones') && foodRow) {
            const alimentoData = datosAlimentoPorFilaDOM.get(foodRow);
            const porciones = parseFloat(target.value);
            if (alimentoData) {
                actualizarValoresNutricionalesFilaAlimento(foodRow, alimentoData, isNaN(porciones) ? 0 : porciones);
            }
        }
    });
    
    tiemposComidaContainer.addEventListener('click', (event) => {
        if (event.target.classList.contains('button-eliminar-alimento')) {
            const foodRow = event.target.closest('tr[data-food-row-id]');
            if (foodRow) {
                handleDeleteFoodRow(foodRow);
            }
        }
    });

    if (btnAnadirTiempoComida) {
        btnAnadirTiempoComida.addEventListener('click', () => {
            const newBlock = createMealTimeBlock();
            updateAllMealTimeSelects(); 
            reorderMealTimeBlocksByTime();
        });
    }
    
    if (btnGuardarRegistroCompleto) {
        btnGuardarRegistroCompleto.addEventListener('click', async () => {
            const notasAGuardar = notasGeneralesTextarea.value;
            const detallesAGuardar = [];
            let esValidoGeneral = true;

            tiemposComidaContainer.querySelectorAll('.tiempo-comida-block').forEach(blockDiv => {
                const tiempoComidaSelect = blockDiv.querySelector('.select-tiempo-comida-block');
                const horaInput = blockDiv.querySelector('.input-hora-block');
                const tiempoComidaId = tiempoComidaSelect.value;
                const horaTiempoComida = horaInput.value;

                if (!tiempoComidaId || !horaTiempoComida) {
                    esValidoGeneral = false;
                    tiempoComidaSelect.style.borderColor = !tiempoComidaId ? 'red' : '';
                    horaInput.style.borderColor = !horaTiempoComida ? 'red' : '';
                    return; 
                } else {
                    tiempoComidaSelect.style.borderColor = '';
                    horaInput.style.borderColor = '';
                }

                let alimentosEnBloque = 0;
                blockDiv.querySelectorAll('tbody tr[data-food-row-id]').forEach(foodRow => {
                    const alimentoSelect = foodRow.querySelector('.select-alimento');
                    const porcionesInput = foodRow.querySelector('.input-porciones');
                    const alimentoId = alimentoSelect.value;
                    const porciones = parseFloat(porcionesInput.value);
                    
                    if (alimentoId && !isNaN(porciones) && porciones > 0) {
                        alimentosEnBloque++;
                        alimentoSelect.style.borderColor = '';
                        porcionesInput.style.borderColor = '';
                        detallesAGuardar.push({
                            pacienteId: parseInt(pacienteId),
                            horaTiempoComida: horaTiempoComida,
                            tiempoComidaId: parseInt(tiempoComidaId),
                            numeroPorciones: porciones,
                            alimentoId: parseInt(alimentoId),
                            notas: notasAGuardar // Enviando la nota general con cada detalle
                        });
                    } else if (alimentoId || (porcionesInput.value && porcionesInput.value !== "1")) { 
                        esValidoGeneral = false;
                        alimentoSelect.style.borderColor = !alimentoId ? 'red' : '';
                        porcionesInput.style.borderColor = (isNaN(porciones) || porciones <= 0) ? 'red' : '';
                    }
                });
                 
            });

            if (!esValidoGeneral) {
                Swal.fire('Campos incompletos', 'Por favor, complete todos los campos obligatorios (Tiempo, Hora, Alimento, Porciones > 0) en cada registro.', 'warning');
                return;
            }

            Swal.fire({
                title: 'Guardando Registro',
                text: 'Por favor, espere...',
                allowOutsideClick: false,
                didOpen: () => { Swal.showLoading(); }
            });

            // Para que el guardado de notas sea más explícito si no hay alimentos:
            let promesasGuardado = [];
            if (detallesAGuardar.length > 0) {
                promesasGuardado = detallesAGuardar.map(detalle =>
                    fetchAPI('https://nutrilinkapi-production.up.railway.app/api_nutrilink/dieta/guardar_detalle_dieta', 'detalle de dieta', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                        body: JSON.stringify(detalle)
                    }).catch(error => ({ error: true, message: error.message, detalle }))
                );
            } else if (notasAGuardar.trim()) {
                
                const payloadSoloNotas = {
                    pacienteId: parseInt(pacienteId),
                    notas: notasAGuardar,
                };
                console.warn("Intentando guardar solo notas. El backend debe estar preparado para esto o se necesita un endpoint dedicado.");
                promesasGuardado.push(
                     fetchAPI('https://nutrilinkapi-production.up.railway.app/api_nutrilink/dieta/guardar_detalle_dieta', 'notas de dieta', { // Ajustar nombre entidad
                        method: 'POST', // O PUT si es a un recurso de dieta existente
                        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                        body: JSON.stringify(payloadSoloNotas) // Backend debe saber qué hacer con esto
                    }).catch(error => ({ error: true, message: error.message, detalle: { notas: notasAGuardar } }))
                );
            }


            if (promesasGuardado.length === 0 && !notasAGuardar.trim()) {
                 Swal.fire('Sin datos', 'No hay registros de comida ni notas para guardar.', 'info');
                 return;
            }


            try {
                const resultados = await Promise.all(promesasGuardado);
                const errores = resultados.filter(r => r.error);

                if (errores.length > 0) {
                    const mensajesError = errores.map(e => {
                        const tipo = e.detalle.alimentoId ? `Alimento ID ${e.detalle.alimentoId}` : (e.detalle.notas ? "Notas generales" : "Registro");
                        return `${tipo}: ${e.message}`;
                    }).join('<br>');
                    Swal.fire('Error al Guardar', `Algunos datos no se pudieron guardar:<br>${mensajesError}`, 'error');
                } else {
                    Swal.fire('¡Guardado!', 'El registro dietario ha sido guardado exitosamente.', 'success');
                    await cargarYMostrarResumenNutricionalYDetalles(); 
                }
            } catch (errorGeneral) { 
                Swal.fire('Error Crítico', `Ocurrió un error inesperado al procesar los guardados: ${errorGeneral.message}`, 'error');
            }
        });
    }

    async function cargarYMostrarResumenNutricionalYDetalles() {
        if (!pacienteId) {
            adecuacionStatusDiv.textContent = "ID de paciente no disponible.";
            adecuacionStatusDiv.className = 'info';
            return;
        }
        adecuacionStatusDiv.textContent = "Cargando datos del registro...";
        adecuacionStatusDiv.className = 'loading';
        
        tiemposComidaContainer.innerHTML = ''; 
        mealTimeBlockCounter = 0; 
        datosAlimentoPorFilaDOM.clear(); 
        tablaAdecuacionCuerpo.querySelectorAll('td[data-consumido], td[data-adecuacion]').forEach(td => td.textContent = '-');
        notasGeneralesTextarea.value = ''; // Limpiar notas antes de cargar

        try {
            // 1. Obtener el resumen nutricional para la tabla de adecuación
            const urlResumen = `https://nutrilinkapi-production.up.railway.app/api_nutrilink/dieta/obtener_resumen_nutricional?pacienteId=${pacienteId}`;
            const resumenResponse = await fetchAPI(urlResumen, 'resumen nutricional');

            if (resumenResponse.status === "success" && resumenResponse.data) {
                const resumenData = resumenResponse.data;
                if (resumenData.adecuacion) {
                    for (const key in resumenData.adecuacion) {
                        const tdAdecuacion = tablaAdecuacionCuerpo.querySelector(`td[data-adecuacion="${key}"]`);
                        if (tdAdecuacion) tdAdecuacion.textContent = `${parseFloat(resumenData.adecuacion[key] || 0).toFixed(1)} %`;
                    }
                }
                if (resumenData.totales_consumidos) {
                     for (const key in resumenData.totales_consumidos) {
                        const tdConsumido = tablaAdecuacionCuerpo.querySelector(`td[data-consumido="${key}"]`);
                        if (tdConsumido) {
                            const valor = parseFloat(resumenData.totales_consumidos[key] || 0);
                            tdConsumido.textContent = key === 'dieta_calorias' ? valor.toFixed(0) : valor.toFixed(1);
                        }
                    }
                }
                adecuacionStatusDiv.textContent = "Resumen y adecuación actualizados.";
                adecuacionStatusDiv.className = 'success';
            } else if (resumenResponse.status === "not_found" || !resumenResponse.data || (resumenResponse.data.detalles_por_tiempo_comida && resumenResponse.data.detalles_por_tiempo_comida.length === 0 && !resumenResponse.data.totales_consumidos)) {
                 adecuacionStatusDiv.textContent = "No hay datos de adecuación para este paciente aún.";
                 if (adecuacionStatusDiv.className !== 'success') adecuacionStatusDiv.className = 'info';
            } else {
                if (adecuacionStatusDiv.className !== 'success') {
                    adecuacionStatusDiv.textContent = `Advertencia: ${resumenResponse.mensaje || "No se pudo obtener adecuación."}`;
                    adecuacionStatusDiv.className = 'warning';
                }
            }

            // 2. Obtener los detalles de la dieta para poblar la UI editable
            // USA EL NUEVO ENDPOINT Y ESTRUCTURA DE RESPUESTA
            const urlDetalles = `https://nutrilinkapi-production.up.railway.app/api_nutrilink/dieta/detalles_dieta?pacienteId=${pacienteId}`;
            const detallesResponse = await fetchAPI(urlDetalles, 'detalles de dieta');

            if (detallesResponse.status === "success" && detallesResponse.data) {
                const datosDieta = detallesResponse.data;
                if (datosDieta.notas) {
                    notasGeneralesTextarea.value = datosDieta.notas;
                }

                if (datosDieta.detalles && datosDieta.detalles.length > 0) {
                    const detallesAgrupados = datosDieta.detalles.reduce((acc, detalle) => {
                        const key = `${detalle.id_tiempo_comida}-${detalle.hora_tiempo_comida}`; // Agrupar por tiempo Y hora
                        if (!acc[key]) {
                            acc[key] = {
                                id_tiempo_comida: detalle.id_tiempo_comida,
                                hora_tiempo_comida: detalle.hora_tiempo_comida,
                                alimentos: []
                            };
                        }
                        acc[key].alimentos.push({
                            alimento_id_alimento: detalle.alimento_id_alimento, 
                            numero_porciones_dieta: detalle.numero_porciones_dieta 
                        });
                        return acc;
                    }, {});

                    Object.values(detallesAgrupados).forEach(grupo => {
                        createMealTimeBlock(grupo.id_tiempo_comida, grupo.hora_tiempo_comida, grupo.alimentos);
                    });
                    
                    if (adecuacionStatusDiv.className !== 'success' && adecuacionStatusDiv.className !== 'warning') {
                         adecuacionStatusDiv.textContent = "Registro cargado para edición.";
                         adecuacionStatusDiv.className = 'info'; 
                    }
                } else { // No hay detalles de alimentos, pero pueden haber notas
                     if (adecuacionStatusDiv.className !== 'success' && adecuacionStatusDiv.className !== 'warning') {
                        adecuacionStatusDiv.textContent = datosDieta.notas ? "Notas cargadas. No hay alimentos registrados." : "No hay alimentos registrados. Puede empezar a añadir.";
                        adecuacionStatusDiv.className = 'info';
                     }
                }
            } else { 
                if (adecuacionStatusDiv.className !== 'success' && adecuacionStatusDiv.className !== 'warning') {
                    adecuacionStatusDiv.textContent = `Error al cargar detalles para edición: ${detallesResponse.mensaje || 'Respuesta inesperada.'}`;
                    adecuacionStatusDiv.className = 'error';
                } else {
                    console.warn(`Error al cargar detalles para edición: ${detallesResponse.mensaje || 'Respuesta inesperada.'}, pero resumen/adecuacion se mostró.`);
                }
            }
            
            if (tiemposComidaContainer.children.length === 0 && ALL_TIEMPOS_COMIDA_DATA && ALL_TIEMPOS_COMIDA_DATA.length > 0) {
                const newBlock = createMealTimeBlock(); 
                 updateAllMealTimeSelects(); 
                 reorderMealTimeBlocksByTime();
                 if (adecuacionStatusDiv.className !== 'success' && adecuacionStatusDiv.className !== 'warning' && adecuacionStatusDiv.className !== 'error') {
                    adecuacionStatusDiv.textContent = "Listo para añadir registros.";
                    adecuacionStatusDiv.className = 'info';
                 }
            }

        } catch (error) {
            console.error("Error al cargar resumen y/o detalles:", error);
            adecuacionStatusDiv.textContent = `Error general al cargar datos: ${error.message}`;
            adecuacionStatusDiv.className = 'error';
            if (tiemposComidaContainer.children.length === 0 && ALL_TIEMPOS_COMIDA_DATA && ALL_TIEMPOS_COMIDA_DATA.length > 0) {
                const newBlock = createMealTimeBlock();
                updateAllMealTimeSelects();
                reorderMealTimeBlocksByTime();
            }
        } finally {
            updateAllMealTimeSelects(); 
            reorderMealTimeBlocksByTime(); 
            updateAddMealButtonState();
            setTimeout(() => {
                if (adecuacionStatusDiv.className === 'success' || adecuacionStatusDiv.className === 'info') {
                    
                }
            }, 4000);
        }
    }

    async function initializePage() {
        adecuacionStatusDiv.textContent = "Cargando datos base...";
        adecuacionStatusDiv.className = 'loading';
        try {
            await cargarDatosBase(); 
            await cargarYMostrarResumenNutricionalYDetalles();
        } catch (error) {
            adecuacionStatusDiv.textContent = "Error al inicializar la página. Intente recargar.";
            adecuacionStatusDiv.className = 'error';
        }
    }

    initializePage();
});
</script>
{% endblock %}